let e=Promise,t=(l,n,o,r,s,f,u,a)=>e.resolve().then((async()=>u(...f.length?await e.all(f):f))).then((e=>{if(o.set(f,e),--s[0]){let f=r.get(u);if(f)for(let i of f)i[i.indexOf(u)]=e,i.every((e=>"function"!=typeof e))&&t(l,n,o,r,s,i,o.get(i),a)}else l([...o.values()][a])}),n),l=()=>{let l=new Map,n=(n=l.size-1)=>((l,n)=>new e(((e,o)=>{let r=new Map,s=new Map;for(let[e,t]of l){let l=[...e];r.set(l,t);for(let e of l)if("function"==typeof e){let t=s.get(e);t?t.push(l):s.set(e,[l])}}let f=[r.size];for(let[l,u]of r)l.every((e=>"function"!=typeof e))&&t(e,o,r,s,f,l,u,n)})))(l,n);return n.add=(e,...t)=>(l.set(t,e),n),n},n=t=>{let l,n,o,r=0,s=()=>r--,f=()=>n=null,u=(o,a,i,w)=>(async e=>{if(!y||r<y)return y&&(r++,setTimeout(s,p)),t(...e);throw"Too many requests"})(o).then((e=>{h&&(n=e,setTimeout(f,h)),l=0,a(e)}),(t=>{c?e.resolve(c(t,++w)).then((()=>u(o,a,i,w))).catch((e=>{l=0,i(e)})):(l=0,i(t))})),a=(e,t,n,r)=>{o==r?(o=null,l=1,u(e,t,n,0)):n("Request be debounced")},i=(...t)=>{let r,s,f=new e(((e,t)=>{r=e,s=t}));return null!=n?r(n):l?s("Request already in progress"):((e,t,n,r)=>{w?(o=r,setTimeout(a,w,e,t,n,r)):(l=1,u(e,t,n,0))})(t,r,s,f),f},h=0;i.cache=e=>(h=1e3*e,i);let c,y=0,p=0;i.throttle=(e,t)=>(y=e,p=t,i),i.retries=e=>(c=e,i);let w=0;return i.debounce=e=>(w=e,i),i},o=(t,...l)=>new e((n=>{let o=l.length;o<t&&(t=o);let r=0,s=()=>{r<o?f(l,r++):++r==o+t&&n(l)},f=(t,l)=>e.resolve().then(t[l]).then((e=>t[l]={value:e}),(e=>t[l]={reason:e})).finally(s);for(;r<t;)f(l,r++)}));export{l as dag,n as decorator,o as parallel}